## The Evolution of Zero-Knowledge Proofs: A Timeline and Comparison

The field of zero-knowledge proofs has experienced a surge of exciting advancements in recent years, revolutionizing areas like privacy, scalability, and security in blockchain and cryptographic systems. From innovations like zk-SNARKs and zk-STARKs to the development of trustless systems and recursive proofs, the pace of progress is remarkable. However, with so many breakthroughs happening rapidly, it can be overwhelming to keep up with the latest protocols, implementations, and use cases. This post aims to simplify and highlight some of the most impactful developments in zero-knowledge technology.

<div style="width: 100%; text-align: center;">

  <div style="display: inline-block; width: 150%;">

   
    <table border="1" style="width: 100%; margin-left: -15%; border-collapse: collapse; font-size: 0.8em;">
      <thead>
        <tr>
          <th>Year</th>
          <th>Name</th>
          <th>Computational Model</th>
          <th>Prover</th>
          <th>Proof Size</th>
          <th>Verifier</th>
          <th>Setup</th>
          <th>Security Assumptions</th>
          <th>Notes</th>
          <th>Recursion?</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2013</td>
          <td>Pinocchio</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>QAP</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2016</td>
          <td>Groth16</td>
          <td></td>
          <td>$O(n \log n)$</td>
          <td>$O(1)$</td>
          <td>$O(1)$</td>
          <td></td>
          <td>q-PKE</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2017</td>
          <td>Hyrax</td>
          <td>Data-parallel Circuits</td>
          <td>$O(n + m * g)$</td>
          <td>$O(m + \sqrt w)$</td>
          <td>$O(m + \sqrt w)$</td>
          <td>Transparent</td>
          <td>DL</td>
          <td>Layered circuits</td>
          <td></td>
        </tr>
        <tr>
          <td>2017</td>
          <td>Ligero</td>
          <td>Arithmetic Circuits</td>
          <td>$O(n \log n)$</td>
          <td>$O(\sqrt n)$</td>
          <td>$O(n)$</td>
          <td>Transparent</td>
          <td>CRHF</td>
          <td>MPC-Based</td>
          <td></td>
        </tr>
        <tr>
          <td>2017</td>
          <td>Bulletproofs</td>
          <td>Arithmetic Circuits</td>
          <td>$O(n)$</td>
          <td>$O(\log n)$</td>
          <td>$O(n)$</td>
          <td>Transparent</td>
          <td>DL</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2017</td>
          <td>BCG+</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2018</td>
          <td>STARKs</td>
          <td>AIR, Uniform Circuits</td>
          <td>$O( n \log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>Transparent</td>
          <td>CRHF</td>
          <td>IOP</td>
          <td></td>
        </tr>
        <tr>
          <td>2018</td>
          <td>Aurora</td>
          <td>R1CS</td>
          <td>$O( n \log n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(n)$</td>
          <td>Transparent</td>
          <td>CRHF</td>
          <td>IOP</td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>Sonic</td>
          <td></td>
          <td>$O( n \log n)$</td>
          <td></td>
          <td>$O(1)$</td>
          <td>Updatable, Universal SRS</td>
          <td>AGM</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>PLONK</td>
          <td></td>
          <td>$O( n \log n)$</td>
          <td></td>
          <td></td>
          <td>Updatable, Universal SRS</td>
          <td></td>
          <td>Permutation Argument</td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>Marlin</td>
          <td></td>
          <td>$O( n \log n)$</td>
          <td></td>
          <td></td>
          <td>Updatable, Universal SRS</td>
          <td></td>
          <td>Algebraic holographic proof for R1CS</td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>Fractal</td>
          <td>R1CS</td>
          <td>$O( n \log n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td></td>
          <td></td>
          <td>Recursive proofs</td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>Libra</td>
          <td>Uniform Circuits</td>
          <td>$O(n)$</td>
          <td>O( d log n)</td>
          <td>O( d log n)</td>
          <td>$O(n)$ One-time trusted setup</td>
          <td>q-SBDH, q-PKE</td>
          <td>"optimal prover time and succinct proof size/verification time"</td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>Halo</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>Recursive proofs, Cycles of Elliptic Curves</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>SuperSonic</td>
          <td>Arithmetic Circuits</td>
          <td>$O( n \log n)$</td>
          <td>$O( \log n)$</td>
          <td>O ( log n)</td>
          <td>Transparent</td>
          <td></td>
          <td>Groups of Unknown Order</td>
          <td></td>
        </tr>
        <tr>
          <td>2019</td>
          <td>Virgo</td>
          <td>Layered Arithmetic Circuits</td>
          <td>O( C + n log n )</td>
          <td>O (D log C + log^2 n)</td>
          <td>O( D log C + log^2 n)</td>
          <td></td>
          <td>CRHF</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2020</td>
          <td>Spartan DL</td>
          <td>R1CS</td>
          <td>$O(n)$</td>
          <td>O( sqrt n)</td>
          <td>O( sqrt n)</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2020</td>
          <td>Spartan KE</td>
          <td>R1CS</td>
          <td>$O(n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2020</td>
          <td>Spartan RO</td>
          <td>R1CS</td>
          <td>$O( n \log n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2020</td>
          <td>Spartan CL</td>
          <td>R1CS</td>
          <td>$O( n \log n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2020</td>
          <td>Halo Infinite</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2021</td>
          <td>Nova</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>Recursive, Folding Schemes, "Halo to the extreme"</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2021</td>
          <td>Brakedown</td>
          <td>R1CS</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2021</td>
          <td>Shockwave (Breakdown Variant)</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2022</td>
          <td>HyperPlonk</td>
          <td></td>
          <td>$O(n)$</td>
          <td></td>
          <td></td>
          <td></td>
          <td>Plonk on the bool hypercube; Multilinear polynomial commitments</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2022</td>
          <td>SuperNova</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>Recursive proof system</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2022</td>
          <td>Orion</td>
          <td></td>
          <td>$O(n)$</td>
          <td>$O(\log^2 n)$</td>
          <td>$O(\log^2 n)$</td>
          <td></td>
          <td>Good performance in practice, Multilinear polynomial commitment scheme</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2023</td>
          <td>SuperSpartan</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>2023</td>
          <td>HyperNova</td>
          <td>CCS</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>CSS generalizes R1CS, AIR, PLONKish. Folding scheme for CSS</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>Halo2</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>Like Halo, but uses PLONK arithmetization instead of Sonic's</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>Plonky</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>Plonky2</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>UltraPLONK</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>PlonkUp</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
      </tbody>
    </table>



  </div>

</div>



# BSCTV 13 SNARK

# Pinocchio
[Pinocchio: Nearly Practical Verifiable Computation](https://eprint.iacr.org/2013/279)

# Groth16
[On the Size of Pairing-based Non-interactive Arguments?](https://eprint.iacr.org/2016/260)


- Trusted Setup: Groth16 requires a trusted setup, meaning it has an initial phase where cryptographic parameters (public and private keys) are generated. This phase must be conducted honestly by participants or a trusted authority because any compromise in this phase could lead to security issues, such as creating fake proofs.
The trusted setup involves creating the Structured Reference String (SRS), a set of public parameters that will be used in all future proof generations and verifications.
Small Proof Size:

- Groth16 is extremely efficient in terms of proof size. It produces constant-sized proofs, typically 128 bytes long, regardless of the complexity of the statement being proven.
This is one of the smallest proof sizes among zk-SNARKs, which is beneficial for reducing the data footprint, especially in blockchain systems where storage space is a critical resource.
Fast Verification:

- The verification process in Groth16 is highly efficient. The verification time is constant, meaning it does not grow with the size of the computation being proved, but rather remains stable, which is crucial for scaling.
It uses pairing-based cryptography, specifically bilinear pairings, which contribute to its fast verification.
Efficient Proof Generation:

- The proof generation process in Groth16 is relatively efficient compared to other zk-SNARK systems, though it still requires considerable computational resources. This efficiency is achieved through pre-processed circuit representations and arithmetic encodings of statements.

**Implementation**:
-  [arkworks-rs/groth16](https://github.com/arkworks-rs/groth16)

# Hyrax

# Ligero

# Bulletproofs

# BCG+

# STARKs

# Aurora

# Sonic

# PLONK

# Marlin

# Fractal

# Libra

# Halo

# SuperSonic

# Virgo

# Spartan DL

# Spartan KE

# Spartan RO

# Spartan CL

# Halo Infinite

# Nova

# Brakedown

# Shockwave (Breakdown Variant)

# HyperPlonk

# SuperNova

# Orion

# SuperSpartan

# HyperNova

# Halo2

# Plonky

# Plonky2

# UltraPLONK

# PlonkUp
